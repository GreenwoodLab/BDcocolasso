% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/blockwise_coordinate_descent.R
\name{blockwise_coordinate_descent}
\alias{blockwise_coordinate_descent}
\title{Blockwise coordinate descent}
\usage{
blockwise_coordinate_descent(
  Z,
  y,
  n,
  p,
  p1,
  p2,
  center.Z = TRUE,
  scale.Z = TRUE,
  center.y = TRUE,
  scale.y = TRUE,
  lambda.factor = ifelse(dim(Z)[1] < dim(Z)[2], 0.01, 0.001),
  step = 100,
  K = 4,
  mu = 10,
  tau = NULL,
  etol = 1e-04,
  optTol = 1e-05,
  earlyStopping_max = 10,
  noise = c("additive", "missing"),
  penalty = c("lasso", "SCAD"),
  mode = "ADMM"
)
}
\arguments{
\item{Z}{Corrupted design matrix (with additive error or missing data)}

\item{y}{Response vector}

\item{n}{Number of samples of the design matrix}

\item{p}{Number of features of the matrix}

\item{p1}{Number of uncorrupted predictors}

\item{p2}{Number of corrupted predictors}

\item{center.Z}{If TRUE, centers Z matrix without taking into account NAs values, and then change NAs to 0 value (in the
missing data setting).}

\item{scale.Z}{If TRUE, divides Z columns by their standard deviation}

\item{center.y}{If TRUE, centers y}

\item{scale.y}{If TRUE, divides y by its standard deviation}

\item{lambda.factor}{Range of the lambda interval we are going to explore}

\item{step}{Number of values of lambda in the interval we are going to test}

\item{K}{Number of folds for the cross-validation}

\item{mu}{Penalty parameter for the ADMM algorithm}

\item{tau}{Standard deviation for the additive error matrix in the additive error setting (NULL in the missing data setting)}

\item{etol}{Tolerance parameter for the ADMM algorithm}

\item{optTol}{Tolerance parameter for the convergence of the error in the pathwise coordinate descent}

\item{earlyStopping_max}{Number of iterations allowed when error starts increasing}

\item{noise}{Type of noise (additive or missing)}

\item{penalty}{Type of penalty used : can be lasso penalty or SCAD penalty}

\item{mode}{ADMM or HM}
}
\value{
list containing \itemize{
\item \code{lambda.opt} optimal value of lambda corresponding to minimum error
\item \code{lambda.sd} Value of lambda corresponding to error higher than minimum error by one standard deviation
\item \code{beta.opt} Value of beta corresponding to \code{lambda.opt}
\item \code{beta.sd} Value of beta corresponding to \code{lambda.sd}
\item \code{data_error} Dataframe containing errors and their standard deviation for each iteration of the algorithm
\item \code{data_beta} Dataframe containing the values of beta for each iteration of the algorithm
\item \code{earlyStopping} Integer containing the value of iteration when early stopping happens
\item \code{vnames} Column names of Z matrix
\item \code{mean.Z} Mean of Z matrix without the NAs values
\item \code{sd.Z} Standard deviation of Z matrix without the NAs values
\item \code{mean.y} Mean of y matrix
\item \code{sd.y} Standard deviation of y matrix
}
}
\description{
Implement blockwise coordinate descent algorithm. Best penalty value is evaluated through cross-validation.
}
\details{
It is highly recommended to use center.Z = TRUE for the algorithm to work in the case of missing data. Otherwise 
the algorithm will not work the way it is intended.
It is recommended to use center.Z = TRUE, scale.Z = TRUE, center.y = TRUE and scale.y = TRUE for both convergence
and interpretability reasons. The use of center.Z = TRUE in the additive error setting can be subject to discussion,
as it may introduce bias in the algorithm.
For computing speed reasons, if model is not converging or running slow, consider changing \code{mu}, decreasing
\code{etol} or \code{optTol} or decreasing \code{earlyStopping_max}
}
\seealso{
\url{https://arxiv.org/pdf/1510.07123.pdf}
}
